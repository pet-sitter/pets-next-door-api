// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package databasegen

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO
  events (
    id,
    event_type,
    author_id,
    name,
    description,
    media_id,
    topics,
    max_participants,
    fee,
    start_at,
    created_at,
    updated_at
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    NOW(),
    NOW()
  )
RETURNING
  id, event_type, author_id, name, description, media_id, topics, max_participants, fee, start_at, created_at, updated_at, deleted_at
`

type CreateEventParams struct {
	ID              uuid.UUID
	EventType       string
	AuthorID        uuid.UUID
	Name            string
	Description     string
	MediaID         uuid.NullUUID
	Topics          []string
	MaxParticipants sql.NullInt32
	Fee             int32
	StartAt         sql.NullTime
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.ID,
		arg.EventType,
		arg.AuthorID,
		arg.Name,
		arg.Description,
		arg.MediaID,
		pq.Array(arg.Topics),
		arg.MaxParticipants,
		arg.Fee,
		arg.StartAt,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AuthorID,
		&i.Name,
		&i.Description,
		&i.MediaID,
		pq.Array(&i.Topics),
		&i.MaxParticipants,
		&i.Fee,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
UPDATE events
SET
  deleted_at = NOW()
WHERE
  id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const findEvent = `-- name: FindEvent :one
SELECT
  events.id, events.event_type, events.author_id, events.name, events.description, events.media_id, events.topics, events.max_participants, events.fee, events.start_at, events.created_at, events.updated_at, events.deleted_at
FROM
  events
WHERE
  (
    events.deleted_at IS NULL
    OR $1::boolean = TRUE
  )
  AND (events.id = $2 OR $2 IS NULL)
LIMIT
  1
`

type FindEventParams struct {
	IncludeDeleted bool
	ID             uuid.NullUUID
}

func (q *Queries) FindEvent(ctx context.Context, arg FindEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, findEvent, arg.IncludeDeleted, arg.ID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AuthorID,
		&i.Name,
		&i.Description,
		&i.MediaID,
		pq.Array(&i.Topics),
		&i.MaxParticipants,
		&i.Fee,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findEvents = `-- name: FindEvents :many
SELECT
  events.id, events.event_type, events.author_id, events.name, events.description, events.media_id, events.topics, events.max_participants, events.fee, events.start_at, events.created_at, events.updated_at, events.deleted_at
FROM
  events
WHERE
  (
    events.deleted_at IS NULL
    OR $2::boolean = TRUE
  )
  AND (id > $3::uuid OR $3 IS NULL)
  AND (id < $4::uuid OR $4 IS NULL)
  AND (events.author_id = $5 OR $5 IS NULL)
ORDER BY
  events.created_at DESC
LIMIT
  $1
`

type FindEventsParams struct {
	Limit          int32
	IncludeDeleted bool
	Prev           uuid.NullUUID
	Next           uuid.NullUUID
	AuthorID       uuid.NullUUID
}

func (q *Queries) FindEvents(ctx context.Context, arg FindEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, findEvents,
		arg.Limit,
		arg.IncludeDeleted,
		arg.Prev,
		arg.Next,
		arg.AuthorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.AuthorID,
			&i.Name,
			&i.Description,
			&i.MediaID,
			pq.Array(&i.Topics),
			&i.MaxParticipants,
			&i.Fee,
			&i.StartAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET
  name = $1,
  description = $2,
  media_id = $3,
  topics = $4,
  max_participants = $5,
  fee = $6,
  start_at = $7,
  updated_at = NOW()
WHERE
  id = $8
RETURNING
  id, event_type, author_id, name, description, media_id, topics, max_participants, fee, start_at, created_at, updated_at, deleted_at
`

type UpdateEventParams struct {
	Name            string
	Description     string
	MediaID         uuid.NullUUID
	Topics          []string
	MaxParticipants sql.NullInt32
	Fee             int32
	StartAt         sql.NullTime
	ID              uuid.UUID
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, updateEvent,
		arg.Name,
		arg.Description,
		arg.MediaID,
		pq.Array(arg.Topics),
		arg.MaxParticipants,
		arg.Fee,
		arg.StartAt,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AuthorID,
		&i.Name,
		&i.Description,
		&i.MediaID,
		pq.Array(&i.Topics),
		&i.MaxParticipants,
		&i.Fee,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
