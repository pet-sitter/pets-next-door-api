// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package databasegen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO
  events (
    id,
    event_type,
    author_id,
    name,
    description,
    media_id,
    topics,
    max_participants,
    fee,
    start_at,
    created_at,
    updated_at
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    NOW(),
    NOW()
  )
RETURNING
  id,
  author_id,
  name,
  description,
  media_id,
  topics,
  max_participants,
  fee,
  start_at,
  created_at,
  updated_at
`

type CreateEventParams struct {
	ID              uuid.UUID
	EventType       string
	AuthorID        uuid.UUID
	Name            string
	Description     string
	MediaID         uuid.NullUUID
	Topics          []string
	MaxParticipants sql.NullInt32
	Fee             int32
	StartAt         sql.NullTime
}

type CreateEventRow struct {
	ID              uuid.UUID
	AuthorID        uuid.UUID
	Name            string
	Description     string
	MediaID         uuid.NullUUID
	Topics          []string
	MaxParticipants sql.NullInt32
	Fee             int32
	StartAt         sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (CreateEventRow, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.ID,
		arg.EventType,
		arg.AuthorID,
		arg.Name,
		arg.Description,
		arg.MediaID,
		pq.Array(arg.Topics),
		arg.MaxParticipants,
		arg.Fee,
		arg.StartAt,
	)
	var i CreateEventRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Name,
		&i.Description,
		&i.MediaID,
		pq.Array(&i.Topics),
		&i.MaxParticipants,
		&i.Fee,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
UPDATE events
SET
  deleted_at = NOW()
WHERE
  id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const findEventByID = `-- name: FindEventByID :one
SELECT
  (
    events.id,
    events.event_type,
    events.author_id,
    events.name,
    events.description,
    events.media_id,
    events.topics,
    events.max_participants,
    events.fee,
    events.start_at,
    events.created_at,
    events.updated_at
  )
FROM
  events
WHERE
  events.id = $1
  AND (
    events.deleted_at IS NULL
    OR $2::boolean = TRUE
  )
LIMIT
  1
`

type FindEventByIDParams struct {
	ID             uuid.NullUUID
	IncludeDeleted bool
}

func (q *Queries) FindEventByID(ctx context.Context, arg FindEventByIDParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, findEventByID, arg.ID, arg.IncludeDeleted)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const findEvents = `-- name: FindEvents :many
SELECT
  (
    events.id,
    events.event_type,
    events.author_id,
    events.name,
    events.description,
    events.media_id,
    events.topics,
    events.max_participants,
    events.fee,
    events.start_at,
    events.created_at,
    events.updated_at
  )
FROM
  events
  LEFT OUTER JOIN media ON events.media_id = media.id
WHERE
  (
    events.deleted_at IS NULL
    OR $2::boolean = TRUE
  )
  AND id > $3::uuid
  AND id < $4::uuid
  AND events.author_id = $5
ORDER BY
  events.created_at DESC
LIMIT
  $1
`

type FindEventsParams struct {
	Limit          int32
	IncludeDeleted bool
	Prev           uuid.NullUUID
	Next           uuid.NullUUID
	AuthorID       uuid.NullUUID
}

func (q *Queries) FindEvents(ctx context.Context, arg FindEventsParams) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, findEvents,
		arg.Limit,
		arg.IncludeDeleted,
		arg.Prev,
		arg.Next,
		arg.AuthorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET
  name = $1,
  description = $2,
  media_id = $3,
  topics = $4,
  max_participants = $5,
  fee = $6,
  start_at = $7,
  updated_at = NOW()
WHERE
  id = $8
RETURNING
  id,
  author_id,
  name,
  description,
  media_id,
  topics,
  max_participants,
  fee,
  start_at,
  created_at,
  updated_at
`

type UpdateEventParams struct {
	Name            string
	Description     string
	MediaID         uuid.NullUUID
	Topics          []string
	MaxParticipants sql.NullInt32
	Fee             int32
	StartAt         sql.NullTime
	ID              uuid.UUID
}

type UpdateEventRow struct {
	ID              uuid.UUID
	AuthorID        uuid.UUID
	Name            string
	Description     string
	MediaID         uuid.NullUUID
	Topics          []string
	MaxParticipants sql.NullInt32
	Fee             int32
	StartAt         sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (UpdateEventRow, error) {
	row := q.db.QueryRowContext(ctx, updateEvent,
		arg.Name,
		arg.Description,
		arg.MediaID,
		pq.Array(arg.Topics),
		arg.MaxParticipants,
		arg.Fee,
		arg.StartAt,
		arg.ID,
	)
	var i UpdateEventRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Name,
		&i.Description,
		&i.MediaID,
		pq.Array(&i.Topics),
		&i.MaxParticipants,
		&i.Fee,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
