// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: sos_posts.sql

package databasegen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteSOSPostConditionBySOSPostID = `-- name: DeleteSOSPostConditionBySOSPostID :exec
UPDATE
    sos_posts_conditions
SET deleted_at = NOW()
WHERE sos_post_id = $1
`

func (q *Queries) DeleteSOSPostConditionBySOSPostID(ctx context.Context, sosPostID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSOSPostConditionBySOSPostID, sosPostID)
	return err
}

const deleteSOSPostDateBySOSPostID = `-- name: DeleteSOSPostDateBySOSPostID :exec
UPDATE
    sos_posts_dates
SET deleted_at = NOW()
WHERE sos_post_id = $1
`

func (q *Queries) DeleteSOSPostDateBySOSPostID(ctx context.Context, sosPostID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSOSPostDateBySOSPostID, sosPostID)
	return err
}

const deleteSOSPostPetBySOSPostID = `-- name: DeleteSOSPostPetBySOSPostID :exec
UPDATE
    sos_posts_pets
SET deleted_at = NOW()
WHERE sos_post_id = $1
`

func (q *Queries) DeleteSOSPostPetBySOSPostID(ctx context.Context, sosPostID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSOSPostPetBySOSPostID, sosPostID)
	return err
}

const findDatesBySOSPostID = `-- name: FindDatesBySOSPostID :many




SELECT sos_dates.id,
       sos_dates.date_start_at,
       sos_dates.date_end_at,
       sos_dates.created_at,
       sos_dates.updated_at
FROM sos_dates
         INNER JOIN
     sos_posts_dates
     ON sos_dates.id = sos_posts_dates.sos_dates_id
WHERE sos_posts_dates.sos_post_id = $1
  AND sos_posts_dates.deleted_at IS NULL
`

type FindDatesBySOSPostIDRow struct {
	ID          uuid.UUID
	DateStartAt sql.NullTime
	DateEndAt   sql.NullTime
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// -- name: FindSOSPosts :many
// SELECT v_sos_posts.id,
//
//	v_sos_posts.title,
//	v_sos_posts.content,
//	v_sos_posts.reward,
//	v_sos_posts.reward_type,
//	v_sos_posts.care_type,
//	v_sos_posts.carer_gender,
//	v_sos_posts.thumbnail_id,
//	v_sos_posts.author_id,
//	v_sos_posts.created_at,
//	v_sos_posts.updated_at,
//	v_sos_posts.dates,
//	v_pets_for_sos_posts.pets_info,
//	v_media_for_sos_posts.media_info,
//	v_conditions.conditions_info
//
// FROM v_sos_posts
//
//	LEFT JOIN v_pets_for_sos_posts ON v_sos_posts.id = v_pets_for_sos_posts.sos_post_id
//	LEFT JOIN v_media_for_sos_posts ON v_sos_posts.id = v_media_for_sos_posts.sos_post_id
//	LEFT JOIN v_conditions ON v_sos_posts.id = v_conditions.sos_post_id
//
// WHERE v_sos_posts.earliest_date_start_at >= sqlc.narg('earliest_date_start_at')
//
//	AND (sqlc.narg('pet_type') = 'all' OR NOT EXISTS
//	  (SELECT 1
//	   FROM unnest(pet_type_list) AS pet_type
//	   WHERE pet_type <> sqlc.narg('pet_type')))
//
// ORDER BY CASE WHEN sqlc.narg('sort_by') = 'newest' THEN v_sos_posts.created_at END DESC,
//
//	CASE WHEN sqlc.narg('sort_by') = 'deadline' THEN v_sos_posts.earliest_date_start_at END
//
// LIMIT sqlc.narg('limit') OFFSET sqlc.narg('offset');
// -- name: FindSOSPostsByAuthorID :many
// SELECT v_sos_posts.id,
//
//	v_sos_posts.title,
//	v_sos_posts.content,
//	v_sos_posts.reward,
//	v_sos_posts.reward_type,
//	v_sos_posts.care_type,
//	v_sos_posts.carer_gender,
//	v_sos_posts.thumbnail_id,
//	v_sos_posts.author_id,
//	v_sos_posts.created_at,
//	v_sos_posts.updated_at,
//	v_sos_posts.dates,
//	v_pets_for_sos_posts.pets_info,
//	v_media_for_sos_posts.media_info,
//	v_conditions.conditions_info
//
// FROM v_sos_posts
//
//	LEFT JOIN v_pets_for_sos_posts ON v_sos_posts.id = v_pets_for_sos_posts.sos_post_id
//	LEFT JOIN v_media_for_sos_posts ON v_sos_posts.id = v_media_for_sos_posts.sos_post_id
//	LEFT JOIN v_conditions ON v_sos_posts.id = v_conditions.sos_post_id
//
// WHERE v_sos_posts.earliest_date_start_at >= sqlc.narg('earliest_date_start_at')
//
//	AND v_sos_posts.author_id = sqlc.narg('author_id')
//	AND (sqlc.narg('pet_type') = 'all' OR NOT EXISTS
//	  (SELECT 1
//	   FROM unnest(pet_type_list) AS pet_type
//	   WHERE pet_type <> sqlc.narg('pet_type')))
//
// ORDER BY CASE WHEN sqlc.narg('sort_by') = 'newest' THEN v_sos_posts.created_at END DESC,
//
//	CASE WHEN sqlc.narg('sort_by') = 'deadline' THEN v_sos_posts.earliest_date_start_at END
//
// LIMIT sqlc.narg('limit') OFFSET sqlc.narg('offset');
// -- name: FindSOSPostByID :one
// SELECT v_sos_posts.id,
//
//	v_sos_posts.title,
//	v_sos_posts.content,
//	v_sos_posts.reward,
//	v_sos_posts.reward_type,
//	v_sos_posts.care_type,
//	v_sos_posts.carer_gender,
//	v_sos_posts.thumbnail_id,
//	v_sos_posts.author_id,
//	v_sos_posts.created_at,
//	v_sos_posts.updated_at,
//	v_sos_posts.dates,
//	v_pets_for_sos_posts.pets_info,
//	v_media_for_sos_posts.media_info,
//	v_conditions.conditions_info
//
// FROM v_sos_posts
//
//	LEFT JOIN v_pets_for_sos_posts ON v_sos_posts.id = v_pets_for_sos_posts.sos_post_id
//	LEFT JOIN v_media_for_sos_posts ON v_sos_posts.id = v_media_for_sos_posts.sos_post_id
//	LEFT JOIN v_conditions ON v_sos_posts.id = v_conditions.sos_post_id
//
// WHERE v_sos_posts.id = sqlc.narg('id');
func (q *Queries) FindDatesBySOSPostID(ctx context.Context, id uuid.NullUUID) ([]FindDatesBySOSPostIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findDatesBySOSPostID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDatesBySOSPostIDRow
	for rows.Next() {
		var i FindDatesBySOSPostIDRow
		if err := rows.Scan(
			&i.ID,
			&i.DateStartAt,
			&i.DateEndAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSOSDate = `-- name: InsertSOSDate :one
INSERT INTO sos_dates
(id,
 date_start_at,
 date_end_at,
 created_at,
 updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, date_start_at, date_end_at, created_at, updated_at
`

type InsertSOSDateParams struct {
	ID          uuid.UUID
	DateStartAt sql.NullTime
	DateEndAt   sql.NullTime
}

type InsertSOSDateRow struct {
	ID          uuid.UUID
	DateStartAt sql.NullTime
	DateEndAt   sql.NullTime
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) InsertSOSDate(ctx context.Context, arg InsertSOSDateParams) (InsertSOSDateRow, error) {
	row := q.db.QueryRowContext(ctx, insertSOSDate, arg.ID, arg.DateStartAt, arg.DateEndAt)
	var i InsertSOSDateRow
	err := row.Scan(
		&i.ID,
		&i.DateStartAt,
		&i.DateEndAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkResourceMedia = `-- name: LinkResourceMedia :exec
INSERT INTO resource_media
(id,
 media_id,
 resource_id,
 resource_type,
 created_at,
 updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
`

type LinkResourceMediaParams struct {
	ID           uuid.UUID
	MediaID      uuid.UUID
	ResourceID   uuid.UUID
	ResourceType sql.NullString
}

func (q *Queries) LinkResourceMedia(ctx context.Context, arg LinkResourceMediaParams) error {
	_, err := q.db.ExecContext(ctx, linkResourceMedia,
		arg.ID,
		arg.MediaID,
		arg.ResourceID,
		arg.ResourceType,
	)
	return err
}

const linkSOSPostCondition = `-- name: LinkSOSPostCondition :exec
INSERT INTO sos_posts_conditions
(id,
 sos_post_id,
 sos_condition_id,
 created_at,
 updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
`

type LinkSOSPostConditionParams struct {
	ID             uuid.UUID
	SosPostID      uuid.UUID
	SosConditionID uuid.NullUUID
}

func (q *Queries) LinkSOSPostCondition(ctx context.Context, arg LinkSOSPostConditionParams) error {
	_, err := q.db.ExecContext(ctx, linkSOSPostCondition, arg.ID, arg.SosPostID, arg.SosConditionID)
	return err
}

const linkSOSPostDate = `-- name: LinkSOSPostDate :exec
INSERT INTO sos_posts_dates
(id,
 sos_post_id,
 sos_dates_id,
 created_at,
 updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
`

type LinkSOSPostDateParams struct {
	ID         uuid.UUID
	SosPostID  uuid.UUID
	SosDatesID uuid.UUID
}

func (q *Queries) LinkSOSPostDate(ctx context.Context, arg LinkSOSPostDateParams) error {
	_, err := q.db.ExecContext(ctx, linkSOSPostDate, arg.ID, arg.SosPostID, arg.SosDatesID)
	return err
}

const linkSOSPostPet = `-- name: LinkSOSPostPet :exec
INSERT INTO sos_posts_pets
(id,
 sos_post_id,
 pet_id,
 created_at,
 updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
`

type LinkSOSPostPetParams struct {
	ID        uuid.UUID
	SosPostID uuid.UUID
	PetID     uuid.UUID
}

func (q *Queries) LinkSOSPostPet(ctx context.Context, arg LinkSOSPostPetParams) error {
	_, err := q.db.ExecContext(ctx, linkSOSPostPet, arg.ID, arg.SosPostID, arg.PetID)
	return err
}

const updateSOSPost = `-- name: UpdateSOSPost :one
UPDATE
    sos_posts
SET title        = $1,
    content      = $2,
    reward       = $3,
    care_type    = $4,
    carer_gender = $5,
    reward_type  = $6,
    thumbnail_id = $7,
    updated_at   = NOW()
WHERE legacy_id = $8
RETURNING
    legacy_id, author_legacy_id, title, content, reward, care_type, carer_gender, reward_type, thumbnail_id, created_at, updated_at
`

type UpdateSOSPostParams struct {
	Title       sql.NullString
	Content     sql.NullString
	Reward      sql.NullString
	CareType    sql.NullString
	CarerGender sql.NullString
	RewardType  sql.NullString
	ThumbnailID uuid.NullUUID
	LegacyID    int32
}

type UpdateSOSPostRow struct {
	LegacyID       int32
	AuthorLegacyID sql.NullInt64
	Title          sql.NullString
	Content        sql.NullString
	Reward         sql.NullString
	CareType       sql.NullString
	CarerGender    sql.NullString
	RewardType     sql.NullString
	ThumbnailID    uuid.NullUUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) UpdateSOSPost(ctx context.Context, arg UpdateSOSPostParams) (UpdateSOSPostRow, error) {
	row := q.db.QueryRowContext(ctx, updateSOSPost,
		arg.Title,
		arg.Content,
		arg.Reward,
		arg.CareType,
		arg.CarerGender,
		arg.RewardType,
		arg.ThumbnailID,
		arg.LegacyID,
	)
	var i UpdateSOSPostRow
	err := row.Scan(
		&i.LegacyID,
		&i.AuthorLegacyID,
		&i.Title,
		&i.Content,
		&i.Reward,
		&i.CareType,
		&i.CarerGender,
		&i.RewardType,
		&i.ThumbnailID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const writeSOSPost = `-- name: WriteSOSPost :one
INSERT INTO sos_posts
(legacy_id,
 author_legacy_id,
 title,
 content,
 reward,
 care_type,
 carer_gender,
 reward_type,
 thumbnail_id,
 created_at,
 updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
RETURNING legacy_id, author_legacy_id, title, content, reward, care_type, carer_gender, reward_type, thumbnail_id, created_at, updated_at
`

type WriteSOSPostParams struct {
	LegacyID       int32
	AuthorLegacyID sql.NullInt64
	Title          sql.NullString
	Content        sql.NullString
	Reward         sql.NullString
	CareType       sql.NullString
	CarerGender    sql.NullString
	RewardType     sql.NullString
	ThumbnailID    uuid.NullUUID
}

type WriteSOSPostRow struct {
	LegacyID       int32
	AuthorLegacyID sql.NullInt64
	Title          sql.NullString
	Content        sql.NullString
	Reward         sql.NullString
	CareType       sql.NullString
	CarerGender    sql.NullString
	RewardType     sql.NullString
	ThumbnailID    uuid.NullUUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) WriteSOSPost(ctx context.Context, arg WriteSOSPostParams) (WriteSOSPostRow, error) {
	row := q.db.QueryRowContext(ctx, writeSOSPost,
		arg.LegacyID,
		arg.AuthorLegacyID,
		arg.Title,
		arg.Content,
		arg.Reward,
		arg.CareType,
		arg.CarerGender,
		arg.RewardType,
		arg.ThumbnailID,
	)
	var i WriteSOSPostRow
	err := row.Scan(
		&i.LegacyID,
		&i.AuthorLegacyID,
		&i.Title,
		&i.Content,
		&i.Reward,
		&i.CareType,
		&i.CarerGender,
		&i.RewardType,
		&i.ThumbnailID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
