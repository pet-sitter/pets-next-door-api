// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: chats.sql

package databasegen

import (
	"context"
	"database/sql"
	"time"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO chat_rooms
(name,
room_type,
created_at,
updated_at)
VALUES ($1, $2, NOW(), NOW())
RETURNING id, name, room_type, created_at, updated_at
`

type CreateRoomParams struct {
	Name     string
	RoomType string
}

type CreateRoomRow struct {
	ID        int32
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (CreateRoomRow, error) {
	row := q.db.QueryRowContext(ctx, createRoom, arg.Name, arg.RoomType)
	var i CreateRoomRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
UPDATE
    chat_rooms
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRoom, id)
	return err
}

const existsUserInRoom = `-- name: ExistsUserInRoom :one
SELECT EXISTS (
    SELECT 1
    FROM user_chat_rooms
    WHERE room_id = $1 AND user_id = $2
)
`

type ExistsUserInRoomParams struct {
	RoomID int64
	UserID int64
}

func (q *Queries) ExistsUserInRoom(ctx context.Context, arg ExistsUserInRoomParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsUserInRoom, arg.RoomID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findMessageByRoomID = `-- name: FindMessageByRoomID :many
SELECT
    id,
    user_id,
    room_id,
    message_type,
    content
FROM
    chat_messages
WHERE
    room_id = $3
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type FindMessageByRoomIDParams struct {
	Limit  int32
	Offset int32
	RoomID sql.NullInt64
}

type FindMessageByRoomIDRow struct {
	ID          int32
	UserID      int64
	RoomID      int64
	MessageType string
	Content     string
}

func (q *Queries) FindMessageByRoomID(ctx context.Context, arg FindMessageByRoomIDParams) ([]FindMessageByRoomIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findMessageByRoomID, arg.Limit, arg.Offset, arg.RoomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindMessageByRoomIDRow
	for rows.Next() {
		var i FindMessageByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRoomByID = `-- name: FindRoomByID :one
SELECT
    id,
    name,
    room_type,
    created_at,
    updated_at
FROM
    chat_rooms
WHERE
    (chat_rooms.id = $1)
    AND (chat_rooms.deleted_at IS NULL)
`

type FindRoomByIDRow struct {
	ID        int32
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) FindRoomByID(ctx context.Context, id sql.NullInt32) (FindRoomByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findRoomByID, id)
	var i FindRoomByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findUserChatRooms = `-- name: FindUserChatRooms :many
SELECT
    user_chat_rooms.id,
    user_chat_rooms.user_id,
    user_chat_rooms.room_id,
    user_chat_rooms.joined_at,
    users.email,
    users.nickname,
    users.fullname,
    media.url AS profile_image_url,
    users.fb_provider_type,
    users.fb_uid,
    users.created_at,
    users.updated_at,
    chat_rooms.id AS chat_room_id,
    chat_rooms.name AS chat_room_name,
    chat_rooms.room_type AS chat_room_type,
    chat_rooms.created_at AS chat_room_created_at,
    chat_rooms.updated_at AS chat_room_updated_at
FROM
    user_chat_rooms
    JOIN users
        ON users.id = user_chat_rooms.user_id
    JOIN chat_rooms
        ON chat_rooms.id = user_chat_rooms.room_id
    LEFT OUTER JOIN media
        ON users.profile_image_id = media.id
WHERE
    user_chat_rooms.left_at IS NULL
`

type FindUserChatRoomsRow struct {
	ID                int32
	UserID            int64
	RoomID            int64
	JoinedAt          time.Time
	Email             string
	Nickname          string
	Fullname          string
	ProfileImageUrl   sql.NullString
	FbProviderType    sql.NullString
	FbUid             sql.NullString
	CreatedAt         time.Time
	UpdatedAt         time.Time
	ChatRoomID        int32
	ChatRoomName      string
	ChatRoomType      string
	ChatRoomCreatedAt time.Time
	ChatRoomUpdatedAt time.Time
}

func (q *Queries) FindUserChatRooms(ctx context.Context) ([]FindUserChatRoomsRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserChatRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserChatRoomsRow
	for rows.Next() {
		var i FindUserChatRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.JoinedAt,
			&i.Email,
			&i.Nickname,
			&i.Fullname,
			&i.ProfileImageUrl,
			&i.FbProviderType,
			&i.FbUid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomType,
			&i.ChatRoomCreatedAt,
			&i.ChatRoomUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinRoom = `-- name: JoinRoom :one
INSERT INTO user_chat_rooms
(user_id, 
room_id,
joined_at)
VALUES ($1, $2, NOW())
RETURNING id, user_id, room_id, joined_at
`

type JoinRoomParams struct {
	UserID int64
	RoomID int64
}

type JoinRoomRow struct {
	ID       int32
	UserID   int64
	RoomID   int64
	JoinedAt time.Time
}

func (q *Queries) JoinRoom(ctx context.Context, arg JoinRoomParams) (JoinRoomRow, error) {
	row := q.db.QueryRowContext(ctx, joinRoom, arg.UserID, arg.RoomID)
	var i JoinRoomRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoomID,
		&i.JoinedAt,
	)
	return i, err
}

const leaveRoom = `-- name: LeaveRoom :exec
UPDATE 
    user_chat_rooms
SET left_at = NOW()
WHERE user_id = $1
AND room_id = $2
`

type LeaveRoomParams struct {
	UserID int64
	RoomID int64
}

func (q *Queries) LeaveRoom(ctx context.Context, arg LeaveRoomParams) error {
	_, err := q.db.ExecContext(ctx, leaveRoom, arg.UserID, arg.RoomID)
	return err
}

const userExistsInRoom = `-- name: UserExistsInRoom :one
SELECT EXISTS (
    SELECT 1
    FROM user_chat_rooms
    WHERE room_id = $1 AND left_at IS NULL
)
`

func (q *Queries) UserExistsInRoom(ctx context.Context, roomID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsInRoom, roomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const writeMessage = `-- name: WriteMessage :one
INSERT INTO chat_messages
(user_id,
room_id,
message_type,
content,
created_at,
updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
RETURNING id, user_id, room_id, message_type, content, created_at, updated_at
`

type WriteMessageParams struct {
	UserID      int64
	RoomID      int64
	MessageType string
	Content     string
}

type WriteMessageRow struct {
	ID          int32
	UserID      int64
	RoomID      int64
	MessageType string
	Content     string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) WriteMessage(ctx context.Context, arg WriteMessageParams) (WriteMessageRow, error) {
	row := q.db.QueryRowContext(ctx, writeMessage,
		arg.UserID,
		arg.RoomID,
		arg.MessageType,
		arg.Content,
	)
	var i WriteMessageRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoomID,
		&i.MessageType,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
