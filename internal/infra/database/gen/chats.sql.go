// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: chats.sql

package databasegen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO chat_rooms
(id,
 name,
 room_type,
 created_at,
 updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, name, room_type, created_at, updated_at
`

type CreateRoomParams struct {
	ID       uuid.UUID
	Name     string
	RoomType string
}

type CreateRoomRow struct {
	ID        uuid.UUID
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (CreateRoomRow, error) {
	row := q.db.QueryRowContext(ctx, createRoom, arg.ID, arg.Name, arg.RoomType)
	var i CreateRoomRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
UPDATE
    chat_rooms
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRoom, id)
	return err
}

const existsRoom = `-- name: ExistsRoom :one
SELECT EXISTS (SELECT 1
               FROM chat_rooms
               WHERE id = $1
                 AND deleted_at IS NULL
    )
`

func (q *Queries) ExistsRoom(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsRoom, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsUserInRoom = `-- name: ExistsUserInRoom :one
SELECT EXISTS (SELECT 1
               FROM user_chat_rooms
               WHERE room_id = $1
                 AND user_id = $2)
`

type ExistsUserInRoomParams struct {
	RoomID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) ExistsUserInRoom(ctx context.Context, arg ExistsUserInRoomParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsUserInRoom, arg.RoomID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findAllUserChatRoomsByUserUID = `-- name: FindAllUserChatRoomsByUserUID :many
SELECT user_chat_rooms.id,
       user_chat_rooms.user_id,
       user_chat_rooms.room_id,
       user_chat_rooms.joined_at,
       users.email,
       users.nickname,
       users.fullname,
       media.url             AS profile_image_url,
       users.fb_provider_type,
       users.fb_uid,
       users.created_at,
       users.updated_at,
       chat_rooms.id         AS chat_room_id,
       chat_rooms.name       AS chat_room_name,
       chat_rooms.room_type  AS chat_room_type,
       chat_rooms.created_at AS chat_room_created_at,
       chat_rooms.updated_at AS chat_room_updated_at
FROM user_chat_rooms
         JOIN users
              ON users.id = user_chat_rooms.user_id
         JOIN chat_rooms
              ON chat_rooms.id = user_chat_rooms.room_id
         LEFT OUTER JOIN media
                         ON users.profile_image_id = media.id
WHERE user_chat_rooms.left_at IS NULL
  AND chat_rooms.deleted_at IS NULL
  AND user_chat_rooms.user_id = $1
`

type FindAllUserChatRoomsByUserUIDRow struct {
	ID                uuid.UUID
	UserID            uuid.UUID
	RoomID            uuid.UUID
	JoinedAt          time.Time
	Email             string
	Nickname          string
	Fullname          string
	ProfileImageUrl   sql.NullString
	FbProviderType    sql.NullString
	FbUid             sql.NullString
	CreatedAt         time.Time
	UpdatedAt         time.Time
	ChatRoomID        uuid.UUID
	ChatRoomName      string
	ChatRoomType      string
	ChatRoomCreatedAt time.Time
	ChatRoomUpdatedAt time.Time
}

func (q *Queries) FindAllUserChatRoomsByUserUID(ctx context.Context, userID uuid.UUID) ([]FindAllUserChatRoomsByUserUIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllUserChatRoomsByUserUID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllUserChatRoomsByUserUIDRow
	for rows.Next() {
		var i FindAllUserChatRoomsByUserUIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.JoinedAt,
			&i.Email,
			&i.Nickname,
			&i.Fullname,
			&i.ProfileImageUrl,
			&i.FbProviderType,
			&i.FbUid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomType,
			&i.ChatRoomCreatedAt,
			&i.ChatRoomUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBetweenMessagesByRoomID = `-- name: FindBetweenMessagesByRoomID :many
SELECT id,
       user_id,
       room_id,
       message_type,
       content,
       created_at
FROM chat_messages
WHERE chat_messages.deleted_at IS NULL
  AND room_id = $2
  AND id > $3::uuid
  AND id < $4::uuid
ORDER BY chat_messages.created_at ASC
LIMIT $1
`

type FindBetweenMessagesByRoomIDParams struct {
	Limit  int32
	RoomID uuid.UUID
	Prev   uuid.NullUUID
	Next   uuid.NullUUID
}

type FindBetweenMessagesByRoomIDRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	RoomID      uuid.UUID
	MessageType string
	Content     string
	CreatedAt   time.Time
}

func (q *Queries) FindBetweenMessagesByRoomID(ctx context.Context, arg FindBetweenMessagesByRoomIDParams) ([]FindBetweenMessagesByRoomIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findBetweenMessagesByRoomID,
		arg.Limit,
		arg.RoomID,
		arg.Prev,
		arg.Next,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindBetweenMessagesByRoomIDRow
	for rows.Next() {
		var i FindBetweenMessagesByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMessagesByRoomIDAndSize = `-- name: FindMessagesByRoomIDAndSize :many
SELECT id,
       user_id,
       room_id,
       message_type,
       content,
       created_at
FROM chat_messages
WHERE chat_messages.deleted_at IS NULL
  AND room_id = $2
ORDER BY chat_messages.created_at DESC
LIMIT $1
`

type FindMessagesByRoomIDAndSizeParams struct {
	Limit  int32
	RoomID uuid.UUID
}

type FindMessagesByRoomIDAndSizeRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	RoomID      uuid.UUID
	MessageType string
	Content     string
	CreatedAt   time.Time
}

func (q *Queries) FindMessagesByRoomIDAndSize(ctx context.Context, arg FindMessagesByRoomIDAndSizeParams) ([]FindMessagesByRoomIDAndSizeRow, error) {
	rows, err := q.db.QueryContext(ctx, findMessagesByRoomIDAndSize, arg.Limit, arg.RoomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindMessagesByRoomIDAndSizeRow
	for rows.Next() {
		var i FindMessagesByRoomIDAndSizeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findNextMessageByRoomID = `-- name: FindNextMessageByRoomID :many
SELECT id,
       user_id,
       room_id,
       message_type,
       content,
       created_at
FROM chat_messages
WHERE chat_messages.deleted_at IS NULL
  AND room_id = $2
  AND (
    id > $3::uuid
    )
ORDER BY chat_messages.created_at ASC
LIMIT $1
`

type FindNextMessageByRoomIDParams struct {
	Limit  int32
	RoomID uuid.UUID
	Next   uuid.NullUUID
}

type FindNextMessageByRoomIDRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	RoomID      uuid.UUID
	MessageType string
	Content     string
	CreatedAt   time.Time
}

func (q *Queries) FindNextMessageByRoomID(ctx context.Context, arg FindNextMessageByRoomIDParams) ([]FindNextMessageByRoomIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findNextMessageByRoomID, arg.Limit, arg.RoomID, arg.Next)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNextMessageByRoomIDRow
	for rows.Next() {
		var i FindNextMessageByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPrevMessageByRoomID = `-- name: FindPrevMessageByRoomID :many
SELECT id,
       user_id,
       room_id,
       message_type,
       content,
       created_at
FROM chat_messages
WHERE chat_messages.deleted_at IS NULL
  AND room_id = $2
  AND (
    id < $3::uuid
    )
ORDER BY chat_messages.created_at DESC
LIMIT $1
`

type FindPrevMessageByRoomIDParams struct {
	Limit  int32
	RoomID uuid.UUID
	Prev   uuid.NullUUID
}

type FindPrevMessageByRoomIDRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	RoomID      uuid.UUID
	MessageType string
	Content     string
	CreatedAt   time.Time
}

func (q *Queries) FindPrevMessageByRoomID(ctx context.Context, arg FindPrevMessageByRoomIDParams) ([]FindPrevMessageByRoomIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findPrevMessageByRoomID, arg.Limit, arg.RoomID, arg.Prev)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPrevMessageByRoomIDRow
	for rows.Next() {
		var i FindPrevMessageByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRoomByIDAndUserID = `-- name: FindRoomByIDAndUserID :one
SELECT id,
       name,
       room_type,
       created_at,
       updated_at
FROM chat_rooms
WHERE chat_rooms.deleted_at IS NULL
  AND (chat_rooms.id = $1)
  AND EXISTS (SELECT 1
              FROM user_chat_rooms
              WHERE user_id = $2
                AND room_id = chat_rooms.id
                AND left_at IS NULL)
`

type FindRoomByIDAndUserIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type FindRoomByIDAndUserIDRow struct {
	ID        uuid.UUID
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) FindRoomByIDAndUserID(ctx context.Context, arg FindRoomByIDAndUserIDParams) (FindRoomByIDAndUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, findRoomByIDAndUserID, arg.ID, arg.UserID)
	var i FindRoomByIDAndUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hasNextMessages = `-- name: HasNextMessages :one
SELECT EXISTS (
    SELECT 1
    FROM chat_messages
    WHERE chat_messages.deleted_at IS NULL
      AND room_id = $2
      AND id > $1  -- 주어진 next UUID보다 이후 메시지
    LIMIT 1
)
`

type HasNextMessagesParams struct {
	ID     uuid.UUID
	RoomID uuid.UUID
}

func (q *Queries) HasNextMessages(ctx context.Context, arg HasNextMessagesParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasNextMessages, arg.ID, arg.RoomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasPrevMessages = `-- name: HasPrevMessages :one
SELECT EXISTS (
    SELECT 1
    FROM chat_messages
    WHERE chat_messages.deleted_at IS NULL
      AND room_id = $2
      AND id < $1  -- 주어진 prev UUID보다 이전 메시지
    LIMIT 1
)
`

type HasPrevMessagesParams struct {
	ID     uuid.UUID
	RoomID uuid.UUID
}

func (q *Queries) HasPrevMessages(ctx context.Context, arg HasPrevMessagesParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasPrevMessages, arg.ID, arg.RoomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const joinRoom = `-- name: JoinRoom :one
INSERT INTO user_chat_rooms
(id,
 user_id,
 room_id,
 joined_at)
VALUES ($1, $2, $3, NOW())
RETURNING id, user_id, room_id, joined_at
`

type JoinRoomParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	RoomID uuid.UUID
}

type JoinRoomRow struct {
	ID       uuid.UUID
	UserID   uuid.UUID
	RoomID   uuid.UUID
	JoinedAt time.Time
}

func (q *Queries) JoinRoom(ctx context.Context, arg JoinRoomParams) (JoinRoomRow, error) {
	row := q.db.QueryRowContext(ctx, joinRoom, arg.ID, arg.UserID, arg.RoomID)
	var i JoinRoomRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoomID,
		&i.JoinedAt,
	)
	return i, err
}

const joinRooms = `-- name: JoinRooms :exec
INSERT INTO user_chat_rooms
(user_id,
 room_id,
 joined_at)
VALUES ($1, $2, NOW())
RETURNING id, user_id, room_id, joined_at
`

type JoinRoomsParams struct {
	UserID uuid.UUID
	RoomID uuid.UUID
}

func (q *Queries) JoinRooms(ctx context.Context, arg JoinRoomsParams) error {
	_, err := q.db.ExecContext(ctx, joinRooms, arg.UserID, arg.RoomID)
	return err
}

const leaveRoom = `-- name: LeaveRoom :exec
UPDATE
    user_chat_rooms
SET left_at = NOW()
WHERE user_id = $1
  AND room_id = $2
`

type LeaveRoomParams struct {
	UserID uuid.UUID
	RoomID uuid.UUID
}

func (q *Queries) LeaveRoom(ctx context.Context, arg LeaveRoomParams) error {
	_, err := q.db.ExecContext(ctx, leaveRoom, arg.UserID, arg.RoomID)
	return err
}

const userExistsInRoom = `-- name: UserExistsInRoom :one
SELECT EXISTS (SELECT 1
               FROM user_chat_rooms
               WHERE room_id = $1
                 AND left_at IS NULL)
`

func (q *Queries) UserExistsInRoom(ctx context.Context, roomID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsInRoom, roomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
