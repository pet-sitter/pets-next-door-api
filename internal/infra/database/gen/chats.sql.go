// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: chats.sql

package databasegen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO chat_rooms
(name,
 room_type,
 created_at,
 updated_at)
VALUES ($1, $2, NOW(), NOW())
RETURNING id, name, room_type, created_at, updated_at
`

type CreateRoomParams struct {
	Name     string
	RoomType string
}

type CreateRoomRow struct {
	ID        uuid.UUID
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (CreateRoomRow, error) {
	row := q.db.QueryRowContext(ctx, createRoom, arg.Name, arg.RoomType)
	var i CreateRoomRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
UPDATE
    chat_rooms
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRoom, id)
	return err
}

const existsUserInRoom = `-- name: ExistsUserInRoom :one
SELECT EXISTS (SELECT 1
               FROM user_chat_rooms
               WHERE room_id = $1
                 AND user_id = $2)
`

type ExistsUserInRoomParams struct {
	RoomID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) ExistsUserInRoom(ctx context.Context, arg ExistsUserInRoomParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsUserInRoom, arg.RoomID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findAllUserChatRoomsByUserUID = `-- name: FindAllUserChatRoomsByUserUID :many
SELECT user_chat_rooms.id,
       user_chat_rooms.user_id,
       user_chat_rooms.room_id,
       user_chat_rooms.joined_at,
       users.email,
       users.nickname,
       users.fullname,
       media.url             AS profile_image_url,
       users.fb_provider_type,
       users.fb_uid,
       users.created_at,
       users.updated_at,
       chat_rooms.id         AS chat_room_id,
       chat_rooms.name       AS chat_room_name,
       chat_rooms.room_type  AS chat_room_type,
       chat_rooms.created_at AS chat_room_created_at,
       chat_rooms.updated_at AS chat_room_updated_at
FROM user_chat_rooms
         JOIN users
              ON users.id = user_chat_rooms.user_id
         JOIN chat_rooms
              ON chat_rooms.id = user_chat_rooms.room_id
         LEFT OUTER JOIN media
                         ON users.profile_image_id = media.id
WHERE user_chat_rooms.left_at IS NULL
  AND chat_rooms.deleted_at IS NULL
  AND user_chat_rooms.user_id = $1
`

type FindAllUserChatRoomsByUserUIDRow struct {
	ID                uuid.UUID
	UserID            uuid.UUID
	RoomID            uuid.UUID
	JoinedAt          time.Time
	Email             string
	Nickname          string
	Fullname          string
	ProfileImageUrl   sql.NullString
	FbProviderType    sql.NullString
	FbUid             sql.NullString
	CreatedAt         time.Time
	UpdatedAt         time.Time
	ChatRoomID        uuid.UUID
	ChatRoomName      string
	ChatRoomType      string
	ChatRoomCreatedAt time.Time
	ChatRoomUpdatedAt time.Time
}

func (q *Queries) FindAllUserChatRoomsByUserUID(ctx context.Context, userID uuid.UUID) ([]FindAllUserChatRoomsByUserUIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllUserChatRoomsByUserUID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllUserChatRoomsByUserUIDRow
	for rows.Next() {
		var i FindAllUserChatRoomsByUserUIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.JoinedAt,
			&i.Email,
			&i.Nickname,
			&i.Fullname,
			&i.ProfileImageUrl,
			&i.FbProviderType,
			&i.FbUid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomType,
			&i.ChatRoomCreatedAt,
			&i.ChatRoomUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMessageByRoomID = `-- name: FindMessageByRoomID :many
SELECT id,
       user_id,
       room_id,
       message_type,
       content,
       created_at
FROM chat_messages
WHERE chat_messages.deleted_at IS NULL
  AND room_id = $2
  AND (($3::uuid IS NOT NULL AND $4::uuid IS NOT NULL AND
        id > $3::uuid AND id < $4::uuid)
    OR
       ($3::uuid IS NOT NULL AND $4::uuid IS NULL AND
        id < $3::uuid)
    OR
       ($3::uuid IS NULL AND $4::uuid IS NOT NULL AND
        id > $4::uuid))
ORDER BY chat_messages.created_at ASC
LIMIT $1
`

type FindMessageByRoomIDParams struct {
	Limit  int32
	RoomID uuid.UUID
	Prev   uuid.NullUUID
	Next   uuid.NullUUID
}

type FindMessageByRoomIDRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	RoomID      uuid.UUID
	MessageType string
	Content     string
	CreatedAt   time.Time
}

func (q *Queries) FindMessageByRoomID(ctx context.Context, arg FindMessageByRoomIDParams) ([]FindMessageByRoomIDRow, error) {
	rows, err := q.db.QueryContext(ctx, findMessageByRoomID,
		arg.Limit,
		arg.RoomID,
		arg.Prev,
		arg.Next,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindMessageByRoomIDRow
	for rows.Next() {
		var i FindMessageByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRoomByIDAndUserID = `-- name: FindRoomByIDAndUserID :one
SELECT id,
       name,
       room_type,
       created_at,
       updated_at
FROM chat_rooms
WHERE chat_rooms.deleted_at IS NULL
  AND (chat_rooms.id = $1)
  AND EXISTS (SELECT 1
              FROM user_chat_rooms
              WHERE user_id = $2
                AND room_id = chat_rooms.id
                AND left_at IS NULL)
`

type FindRoomByIDAndUserIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type FindRoomByIDAndUserIDRow struct {
	ID        uuid.UUID
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) FindRoomByIDAndUserID(ctx context.Context, arg FindRoomByIDAndUserIDParams) (FindRoomByIDAndUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, findRoomByIDAndUserID, arg.ID, arg.UserID)
	var i FindRoomByIDAndUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const joinRoom = `-- name: JoinRoom :one
INSERT INTO user_chat_rooms
(user_id,
 room_id,
 joined_at)
VALUES ($1, $2, NOW())
RETURNING id, user_id, room_id, joined_at
`

type JoinRoomParams struct {
	UserID uuid.UUID
	RoomID uuid.UUID
}

type JoinRoomRow struct {
	ID       uuid.UUID
	UserID   uuid.UUID
	RoomID   uuid.UUID
	JoinedAt time.Time
}

func (q *Queries) JoinRoom(ctx context.Context, arg JoinRoomParams) (JoinRoomRow, error) {
	row := q.db.QueryRowContext(ctx, joinRoom, arg.UserID, arg.RoomID)
	var i JoinRoomRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoomID,
		&i.JoinedAt,
	)
	return i, err
}

const joinRooms = `-- name: JoinRooms :exec
INSERT INTO user_chat_rooms
(user_id,
 room_id,
 joined_at)
VALUES ($1, $2, NOW())
RETURNING id, user_id, room_id, joined_at
`

type JoinRoomsParams struct {
	UserID uuid.UUID
	RoomID uuid.UUID
}

func (q *Queries) JoinRooms(ctx context.Context, arg JoinRoomsParams) error {
	_, err := q.db.ExecContext(ctx, joinRooms, arg.UserID, arg.RoomID)
	return err
}

const leaveRoom = `-- name: LeaveRoom :exec
UPDATE
    user_chat_rooms
SET left_at = NOW()
WHERE user_id = $1
  AND room_id = $2
`

type LeaveRoomParams struct {
	UserID uuid.UUID
	RoomID uuid.UUID
}

func (q *Queries) LeaveRoom(ctx context.Context, arg LeaveRoomParams) error {
	_, err := q.db.ExecContext(ctx, leaveRoom, arg.UserID, arg.RoomID)
	return err
}

const userExistsInRoom = `-- name: UserExistsInRoom :one
SELECT EXISTS (SELECT 1
               FROM user_chat_rooms
               WHERE room_id = $1
                 AND left_at IS NULL)
`

func (q *Queries) UserExistsInRoom(ctx context.Context, roomID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsInRoom, roomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
