// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: chats.sql

package databasegen

import (
	"context"
	"database/sql"
	"time"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO chat_rooms
(name,
room_type,
created_at,
updated_at)
VALUES ($1, $2, NOW(), NOW())
RETURNING id, name, room_type, created_at, updated_at
`

type CreateRoomParams struct {
	Name     string
	RoomType string
}

type CreateRoomRow struct {
	ID        int32
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (CreateRoomRow, error) {
	row := q.db.QueryRowContext(ctx, createRoom, arg.Name, arg.RoomType)
	var i CreateRoomRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
UPDATE
    chat_rooms
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRoom, id)
	return err
}

const existsUserInRoom = `-- name: ExistsUserInRoom :one
SELECT EXISTS (
    SELECT 1
    FROM user_chat_rooms
    WHERE room_id = $1 AND user_id = $2
)
`

type ExistsUserInRoomParams struct {
	RoomID int64
	UserID int64
}

func (q *Queries) ExistsUserInRoom(ctx context.Context, arg ExistsUserInRoomParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsUserInRoom, arg.RoomID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findMessageByRoomID = `-- name: FindMessageByRoomID :many
SELECT
    id,
    user_id,
    room_id,
    message_type,
    content,
	created_at
FROM
    chat_messages
WHERE
	chat_messages.deleted_at IS NULL
AND
    room_id = $4
AND
    (($1 != 0 AND $2 != 0 AND id > $1 AND id < $2) 
OR 
    ($1 != 0 AND $2 = 0 AND id < $1) 
OR 
    ($1 = 0 AND $2 != 0 AND id > $2)) 
ORDER BY
    chat_messages.created_at ASC
LIMIT $3
`

type FindMessageByRoomIDParams struct {
	Prev   int64
	Next   int64
	Limit  int64
	RoomID int64
}

type FindMessageByRoomIDRow struct {
	ID          int32
	UserID      int64
	RoomID      int64
	MessageType string
	Content     string
	CreatedAt   time.Time
}

func (q *Queries) FindMessageByRoomID(ctx context.Context, arg FindMessageByRoomIDParams) (*bool, *bool, []FindMessageByRoomIDRow, error) {
	// Limit + 1로 메시지 조회
	rows, err := q.db.QueryContext(ctx, findMessageByRoomID, arg.Prev, arg.Next, arg.Limit+1, arg.RoomID)
	if err != nil {
		return nil, nil, nil, err
	}
	defer rows.Close()

	var items []FindMessageByRoomIDRow
	hasPrev := false
	hasNext := false
	var firstID int64
	var lastID int64

	for rows.Next() {
		var i FindMessageByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.MessageType,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, nil, nil, err
		}

		// 첫 번째 ID 추출
		if firstID == 0 {
			firstID = int64(i.ID)
		}
		// 마지막 ID 추출
		lastID = int64(i.ID)

		items = append(items, i)
	}

	// Next 이후 메시지가 있는지 확인 (Limit + 1 로 가져와서 확인)
	if int64(len(items)) > arg.Limit {
		hasNext = true
		items = items[:len(items)-1] // 추가된 마지막 항목을 삭제하여 반환된 메시지 수를 Limit에 맞춤
	}

	// 첫 번째 메시지의 ID를 기준으로 이전 메시지가 있는지 확인
	if firstID != 0 {
		checkPrevQuery := `SELECT COUNT(1) FROM chat_messages WHERE room_id = $1 AND id < $2 AND deleted_at IS NULL`
		checkPrevRow := q.db.QueryRowContext(ctx, checkPrevQuery, arg.RoomID, firstID)
		var count int
		if err := checkPrevRow.Scan(&count); err == nil && count > 0 {
			hasPrev = true
		}
	}

	// 마지막 메시지의 ID를 기준으로 이후 메시지가 있는지 확인
	if lastID != 0 {
		checkNextQuery := `SELECT COUNT(1) FROM chat_messages WHERE room_id = $1 AND id > $2 AND deleted_at IS NULL`
		checkNextRow := q.db.QueryRowContext(ctx, checkNextQuery, arg.RoomID, lastID)
		var count int
		if err := checkNextRow.Scan(&count); err == nil && count > 0 {
			hasNext = true
		}
	}

	// 결과 반환
	return &hasNext, &hasPrev, items, nil
}


const findRoomByIDAndUserID = `-- name: FindRoomByIDAndUserID :one
SELECT
    id,
    name,
    room_type,
    created_at,
    updated_at
FROM
    chat_rooms
WHERE
	chat_rooms.deleted_at IS NULL
    AND	(chat_rooms.id = $1)
	AND EXISTS (
		SELECT 1
		FROM user_chat_rooms
		WHERE user_id = $2
		AND room_id = chat_rooms.id
		AND left_at IS NULL
	)
`

type FindRoomByIDRow struct {
	ID        int32
	Name      string
	RoomType  string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt time.Time
}

func (q *Queries) FindRoomByIDAndUserID(ctx context.Context, roomId int64, userId int64) (FindRoomByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findRoomByIDAndUserID, roomId, userId)
	var i FindRoomByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RoomType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAllUserChatRooms = `-- name: FindAllUserChatRoomsByUserUID :many
SELECT
    user_chat_rooms.id,
    user_chat_rooms.user_id,
    user_chat_rooms.room_id,
    user_chat_rooms.joined_at,
    users.email,
    users.nickname,
    users.fullname,
    media.url AS profile_image_url,
    users.fb_provider_type,
    users.fb_uid,
    users.created_at,
    users.updated_at,
    chat_rooms.id AS chat_room_id,
    chat_rooms.name AS chat_room_name,
    chat_rooms.room_type AS chat_room_type,
    chat_rooms.created_at AS chat_room_created_at,
    chat_rooms.updated_at AS chat_room_updated_at
FROM
    user_chat_rooms
    JOIN users
        ON users.id = user_chat_rooms.user_id
    JOIN chat_rooms
        ON chat_rooms.id = user_chat_rooms.room_id
    LEFT OUTER JOIN media
        ON users.profile_image_id = media.id
WHERE
    user_chat_rooms.left_at IS NULL
AND 
	chat_rooms.deleted_at IS NULL
AND
     user_chat_rooms.user_id = $1
`

type FindAllUserChatRoomsRow struct {
	ID                int32
	UserID            int64
	RoomID            int64
	JoinedAt          time.Time
	Email             string
	Nickname          string
	Fullname          string
	ProfileImageUrl   sql.NullString
	FbProviderType    sql.NullString
	FbUid             sql.NullString
	CreatedAt         time.Time
	UpdatedAt         time.Time
	ChatRoomID        int32
	ChatRoomName      string
	ChatRoomType      string
	ChatRoomCreatedAt time.Time
	ChatRoomUpdatedAt time.Time
}

func (q *Queries) FindAllUserChatRoomsByUserUID(ctx context.Context, userId int64) ([]FindAllUserChatRoomsRow, error) {
	rows, err := q.db.QueryContext(ctx, findAllUserChatRooms, userId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllUserChatRoomsRow
	for rows.Next() {
		var i FindAllUserChatRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.JoinedAt,
			&i.Email,
			&i.Nickname,
			&i.Fullname,
			&i.ProfileImageUrl,
			&i.FbProviderType,
			&i.FbUid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChatRoomID,
			&i.ChatRoomName,
			&i.ChatRoomType,
			&i.ChatRoomCreatedAt,
			&i.ChatRoomUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinRoom = `-- name: JoinRoom :one
INSERT INTO user_chat_rooms
(user_id, 
room_id,
joined_at)
VALUES ($1, $2, NOW())
RETURNING id, user_id, room_id, joined_at
`
const joinRooms = `-- name: JoinRooms :exec
INSERT INTO user_chat_rooms
(user_id,
room_id,
joined_at)
VALUES ($1, $2, NOW())
RETURNING id, user_id, room_id, joined_at
`

type JoinRoomParams struct {
	UserID int64
	RoomID int64
}

type JoinRoomsParams struct {
	UserIDs []int64
	RoomID  int64
}

type JoinRoomRow struct {
	ID       int32
	UserID   int64
	RoomID   int64
	JoinedAt time.Time
}

func (q *Queries) JoinRoom(ctx context.Context, arg JoinRoomParams) (JoinRoomRow, error) {
	row := q.db.QueryRowContext(ctx, joinRoom, arg.UserID, arg.RoomID)
	var i JoinRoomRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoomID,
		&i.JoinedAt,
	)
	return i, err
}

func (q *Queries) JoinRooms(ctx context.Context, arg JoinRoomsParams) error {
	rows, err := q.db.QueryContext(ctx, joinRooms, arg.UserIDs, arg.RoomID)
	if err != nil {
		return err
	}
	defer rows.Close()
	var items []JoinRoomRow
	for rows.Next() {
		var i JoinRoomRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoomID,
			&i.JoinedAt,
		); err != nil {
			return err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}
	return nil

}

const leaveRoom = `-- name: LeaveRoom :exec
UPDATE 
    user_chat_rooms
SET left_at = NOW()
WHERE user_id = $1
AND room_id = $2
`

type LeaveRoomParams struct {
	UserID int64
	RoomID int64
}

func (q *Queries) LeaveRoom(ctx context.Context, arg LeaveRoomParams) error {
	_, err := q.db.ExecContext(ctx, leaveRoom, arg.UserID, arg.RoomID)
	return err
}

const userExistsInRoom = `-- name: UserExistsInRoom :one
SELECT EXISTS (
    SELECT 1
    FROM user_chat_rooms
    WHERE room_id = $1 AND left_at IS NULL
)
`

func (q *Queries) UserExistsInRoom(ctx context.Context, roomID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsInRoom, roomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
